"""HMRC Survey of Personal Incomes targets.

Downloads and parses the SPI ODS (Tables 3.6 and 3.7) to get income
distributions by total income band and income type for 2022-23.

For future year projections, the microsimulation uprates these base
year distributions forward using PolicyEngine's uprating factors.
That projection logic is in utils/incomes_projection.py and is not
part of the target download — it's a simulation step.

Source: https://www.gov.uk/government/statistics/income-tax-summarised-accounts-statistics
"""

import io
import logging
from functools import lru_cache
from pathlib import Path

import pandas as pd
import requests
import yaml

from policyengine_uk_data.targets.schema import Target, Unit

logger = logging.getLogger(__name__)

_SOURCES_YAML = Path(__file__).parent.parent / "sources.yaml"
_STORAGE = Path(__file__).parents[2] / "storage"

_HEADERS = {
    "User-Agent": (
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36"
    ),
}

# Income bands in the SPI tables (lower bounds)
_BAND_LOWER = [
    12_570,
    15_000,
    20_000,
    30_000,
    40_000,
    50_000,
    70_000,
    100_000,
    150_000,
    200_000,
    300_000,
    500_000,
    1_000_000,
]
_BAND_UPPER = _BAND_LOWER[1:] + [float("inf")]

# SPI year: the ODS is for tax year 2022-23, mapped to calendar 2023
_SPI_YEAR = 2023


def _load_config():
    with open(_SOURCES_YAML) as f:
        return yaml.safe_load(f)


@lru_cache(maxsize=1)
def _download_ods(url: str) -> bytes:
    """Download an ODS file."""
    r = requests.get(url, headers=_HEADERS, allow_redirects=True, timeout=60)
    r.raise_for_status()
    return r.content


def _parse_table_36(ods_bytes: bytes) -> pd.DataFrame:
    """Parse Table 3.6: employment, self-employment, pensions by band.

    Columns: lower_bound, self_employment_income_count/amount,
    employment_income_count/amount, state_pension_count/amount,
    private_pension_income_count/amount.
    """
    df = pd.read_excel(
        io.BytesIO(ods_bytes),
        sheet_name="Table_3_6",
        engine="odf",
        header=None,
    )
    # Data rows start at row 5, end before "All ranges"
    data_rows = []
    for i in range(5, len(df)):
        lower = df.iloc[i, 0]
        if not isinstance(lower, (int, float)):
            break
        data_rows.append(
            {
                "lower_bound": int(lower),
                "self_employment_income_count": _to_float(df.iloc[i, 1]),
                "self_employment_income_amount": _to_float(df.iloc[i, 2]),
                "employment_income_count": _to_float(df.iloc[i, 4]),
                "employment_income_amount": _to_float(df.iloc[i, 5]),
                "state_pension_count": _to_float(df.iloc[i, 7]),
                "state_pension_amount": _to_float(df.iloc[i, 8]),
                "private_pension_income_count": _to_float(df.iloc[i, 10]),
                "private_pension_income_amount": _to_float(df.iloc[i, 11]),
            }
        )
    return pd.DataFrame(data_rows)


def _parse_table_37(ods_bytes: bytes) -> pd.DataFrame:
    """Parse Table 3.7: property, interest, dividends by band.

    Columns: lower_bound, property_income_count/amount,
    savings_interest_income_count/amount, dividend_income_count/amount.
    """
    df = pd.read_excel(
        io.BytesIO(ods_bytes),
        sheet_name="Table_3_7",
        engine="odf",
        header=None,
    )
    data_rows = []
    for i in range(5, len(df)):
        lower = df.iloc[i, 0]
        if not isinstance(lower, (int, float)):
            break
        data_rows.append(
            {
                "lower_bound": int(lower),
                "property_income_count": _to_float(df.iloc[i, 1]),
                "property_income_amount": _to_float(df.iloc[i, 2]),
                "savings_interest_income_count": _to_float(df.iloc[i, 4]),
                "savings_interest_income_amount": _to_float(df.iloc[i, 5]),
                "dividend_income_count": _to_float(df.iloc[i, 7]),
                "dividend_income_amount": _to_float(df.iloc[i, 8]),
            }
        )
    return pd.DataFrame(data_rows)


def _to_float(val) -> float:
    """Convert cell value to float, handling '[Not available]' etc."""
    if isinstance(val, (int, float)):
        return float(val)
    return 0.0


INCOME_VARIABLES = [
    "employment_income",
    "self_employment_income",
    "state_pension",
    "private_pension_income",
    "property_income",
    "dividend_income",
]


def get_targets() -> list[Target]:
    """Build income-band targets from the live HMRC SPI ODS.

    Also reads incomes_projection.csv if available, which contains
    projected future year data generated by the microsimulation.
    """
    config = _load_config()
    ref = config["hmrc"]["spi_collated"]
    targets = []

    # Parse base year from official ODS
    try:
        ods_bytes = _download_ods(ref)
        t36 = _parse_table_36(ods_bytes)
        t37 = _parse_table_37(ods_bytes)
        merged = t36.merge(t37, on="lower_bound", how="outer")

        for idx, row in merged.iterrows():
            lower = int(row["lower_bound"])
            upper = _BAND_UPPER[idx] if idx < len(_BAND_UPPER) else float("inf")
            band_label = f"{lower:_}_to_{upper:_}"

            for variable in INCOME_VARIABLES:
                amount_col = f"{variable}_amount"
                count_col = f"{variable}_count"

                if amount_col in row.index and row[amount_col] > 0:
                    # SPI amounts are in £millions, counts in thousands
                    targets.append(
                        Target(
                            name=f"hmrc/{variable}_income_band_{band_label}",
                            variable=variable,
                            source="hmrc_spi",
                            unit=Unit.GBP,
                            values={_SPI_YEAR: float(row[amount_col]) * 1e6},
                            breakdown_variable="total_income",
                            lower_bound=float(lower),
                            upper_bound=float(upper),
                            reference_url=ref,
                        )
                    )

                if count_col in row.index and row[count_col] > 0:
                    targets.append(
                        Target(
                            name=(f"hmrc/{variable}_count_income_band_{band_label}"),
                            variable=variable,
                            source="hmrc_spi",
                            unit=Unit.COUNT,
                            values={_SPI_YEAR: float(row[count_col]) * 1e3},
                            is_count=True,
                            breakdown_variable="total_income",
                            lower_bound=float(lower),
                            upper_bound=float(upper),
                            reference_url=ref,
                        )
                    )
    except Exception as e:
        logger.error("Failed to download/parse HMRC SPI ODS: %s", e)

    # Also read projected future years from incomes_projection.csv
    # if it exists (generated by utils/incomes_projection.py)
    proj_path = _STORAGE / "incomes_projection.csv"
    if proj_path.exists():
        targets.extend(_read_projection_csv(proj_path, ref))

    return targets


def _read_projection_csv(csv_path: Path, ref: str) -> list[Target]:
    """Read projected future year targets from incomes_projection.csv."""
    incomes = pd.read_csv(csv_path)
    targets = []

    for year in incomes.year.unique():
        if year <= _SPI_YEAR:
            continue  # Skip base year — we have actuals from ODS
        year_df = incomes[incomes.year == year]

        for _, row in year_df.iterrows():
            lower = row.total_income_lower_bound
            upper = row.total_income_upper_bound
            band_label = f"{lower:_.0f}_to_{upper:_.0f}"

            for variable in INCOME_VARIABLES:
                amount_col = f"{variable}_amount"
                count_col = f"{variable}_count"

                if amount_col in row.index and pd.notna(row[amount_col]):
                    name = f"hmrc/{variable}_income_band_{band_label}"
                    targets.append(
                        Target(
                            name=name,
                            variable=variable,
                            source="hmrc_spi",
                            unit=Unit.GBP,
                            values={int(year): float(row[amount_col])},
                            breakdown_variable="total_income",
                            lower_bound=float(lower),
                            upper_bound=float(upper),
                            reference_url=ref,
                        )
                    )

                if count_col in row.index and pd.notna(row[count_col]):
                    name = f"hmrc/{variable}_count_income_band_{band_label}"
                    targets.append(
                        Target(
                            name=name,
                            variable=variable,
                            source="hmrc_spi",
                            unit=Unit.COUNT,
                            values={int(year): float(row[count_col])},
                            is_count=True,
                            breakdown_variable="total_income",
                            lower_bound=float(lower),
                            upper_bound=float(upper),
                            reference_url=ref,
                        )
                    )

    # Merge targets with the same name across years
    merged: dict[str, Target] = {}
    for t in targets:
        if t.name in merged:
            merged[t.name].values.update(t.values)
        else:
            merged[t.name] = t

    return list(merged.values())
